# JS_Gsheets

JS_Gsheets - небольшая библиотека для построения Базы Данных на основе Google-таблиц.

### Github Page Demo:

> https://albertsadykovofficial.github.io/JS_Gsheets/index.html

### Примечание к использованию:
  
:white_check_mark: Можно использовать как набор разнородных файлов из каталога lib/parts/.

:white_check_mark: Можно использовать файл lib/all_in_one/JS_Gsheets.js как (ВСЕ В ОДНОМ).

### Настройка для использования:

Для использования вам нужно: 

1. Создать Google-таблицу,  
1.1 Опубликовать ее для всех,
1.2 Создать несколько листов по нужде (лист - это таблица нашей БД)
1.3 Скопировать ее хэш
2. Создать Google-скрипт, 
2.1. Всавить содежимое скрипта из папки google_script (https://github.com/AlbertSadykovOfficial/JS_Gsheets/blob/master/google_script /JS_Gsheets.js)
2.2  Вставить в переменную SHEET_KEY - хэш таблицы
2.3 Сохранить изменения.
2.3 Опубликовать скрипт как веб-приложение, сделать его выполнение доступным всем.
2.4 Скопировать его ХЭШ

| Параметр       |	Значение |
|----------------|-------------------------------|
|google_sheet_hash|Ключ ссылки на таблицу (таблица должна быть публичной)|
|google_script_hash|Ключ ссылки на скрипт (скрипт должен быть публичным)|
|[table_name.., .. ]| Имя листа в таблице. |
Параметры объявления:

```javascript
let GSQL = new GSQL_constructor(google_sheet_hash, google_script_hash, [table_name_1, table_name_2, ...]);
```
Пример:

```javascript
let GSQL = new GSQL_constructor('1FGhlktidC_5rmwbY7T1z8Jn76feaJtty5fz0IQVJTz4', 
                                'AKfycbyYYihG8l7QthbD8Pcu6M9jYtyv57Q9KWM15iIQhFKEJL06ed7GKo5SCaXzS1_pGxeaDg', 
                                ['main', 'members', 'sandbox']);
```
---
### Терминология
В терминологии библиотеки:
-   Google-Таблица -> База данных.
-   Отдельные Листы Google-Таблицы -> таблицы Базы данных
Т.е. далее, к примеру, table_name - это не имя Google-таблиц, а имя листа Google-таблицы.
---
### Общая рекомендация перед примерами использования
Стоит понимать, что это библиотека некий эмулятор взаимодействия с БД. Обысно БД находится на одном компьютере с серверным скриптом и время общения между ними-миимально. У нас же другой вариант - мы получаем данные с сервера, обрабатываем их у себя и отправляем данные обратно... Давольно немало времени тратится на передачу данных в одну сторону, а отом в другую. Это, конечно, порождает проблемы с синхронизацией данных. Если данные меняются каждые несколько секунд - не проблема. Но если период обновления около секунды - это проблема.  

Отсюда первая рекомендация - не используйте библиотеку для высоконагруженных приложений, она скорее для простых приложений или для демострации возможности приложения без поднятия сервера (самое то для начинающих).

Вторая рекомендация (для async)- не вызывайте кучу команд сразу в одной функции, особенно это касается последовательности: SELECT -> INSERT или UPDATE или DELETE -> а потом опять SELECT. Пока данные вставляются вызов SELECT во 2й раз не успеет считать новые данные, он скорее всего считает старые.  Лучше делать небольшие функции с 1м вызовом SELECT в начале, а затем нужной нам функцией -> Вставить, Обновить или Удалить. Тогда времени должно хватить. Также лучше пытайтесь изменять (доабвлять, удалять) данные одной командой вместо нескольких, для этого есть специлальный синтаксис. 

Пример:
```javascript
INSERT('sandbox', [['username', user1],['level', level1],['say', says1]]);
INSERT('sandbox', [['username', user2],['level', level2],['say', says2]]);
INSERT('sandbox', [['username', user3],['level', level3],['say', says3]]);
```
Лучше 1 команда, чем предыдущие 3.
```javascript
INSERT('sandbox', [
			['username', [user1, user2, user3]],
			['level', [level1, level2, level3]],
			['say', [says1, says2, says3]]
		]);
```
---
### Примеры использования (для callback-варианта)
#### Вызвать функцию
Чтобы получить данные из google-таблицы, следует вызвать функцию ```queryGSQL()```. Функция выполнит асинхронный запрос к таблице, отфильтрует значения и вернет результат в callback-функцию, которую мы указали. Результатом функции при успешном выполнении является массив коллекций. При ошибке - ошибка, поэтому, чтобы не упал код можно поставить try/catch. 

Принимающая функция должна иметь только 1 аргумент (data)!

Параметры:
| Параметр|	Значение |
|----------------|-------------------------------|
|error_f |callback-функция при ошибке|
|success_f|callback-функция при успешном получении данных|
|table_name | имя таблицы (листа) из которой извлекаем данные|

Синтаксис:
```javascript
queryGSQL(error_f, success_f, table_name); 
```
Пример:
```javascript
queryGSQL(console.log, select_data, 'main');
queryGSQL(custom_log, update_data, 'members');
queryGSQL(custom_alert, insert_data, 'sandbox');
```
Дальше массив данных приходит в указанную нами функцию, через некоторое время, к примеру:
```javascript
function select_data(значения_из_БД)
{
	...наш код
	...тут можно использовать функции, приведенные ниже
}
```
---

#### Команды
#### SELECT
Синтаксис:
```javascript
SELECT('значения из БД', 
		[имя_колонки_1, имя_колонки_2,..., имя_колонки_N], 
		[ 
			[имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]], 
			[имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]],
			...
		]);
```
Пример:

```javascript
function select_data(data)
{
	user_mail = 'top1@mail.ru';
	from_date = new Date('1980-01-01');
	to_date   = new Date('2099-01-01');
	
	result = SELECT(data, ['mail', 'city', 'date', 'doctype'], 
			[ 
				['mail','!=', user_mail], 
				['date', 'from', [from_date]],
				['date', 'to', [to_date]],
			]);
}
```
---
#### COUNT 
Синтаксис абсолютно такой же как и у SELECT: 
```javascript
COUNT('значения из БД', 
		[имя_колонки_1, имя_колонки_2,..., имя_колонки_N], 
		[ 
			[имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]], 
			[имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]],
			...
		]);
```
---
#### INSERT
Синтаксис:
```javascript
INSERT('таблица', [
                      [ имя_колонки, [значение_1, значение_2, ..., значение_N]],
                      [ имя_колонки, [значение_1, значение_2, ..., значение_N]],
                       ...
                    ]);
```
Пример:
```javascript
function insert_data(data)
{
	block = document.getElementById('insert_example_block');

	user = block.getElementsByClassName('UserName')[0].value;
	level = block.getElementsByClassName('level')[0].value;
	says = block.getElementsByClassName('say')[0].value;
	
	INSERT('sandbox', [
		                   ['username', user],
		                   ['level', level],
		                   ['say', says]
	                 ]);
}
```
---
#### UPDATE
Синтаксис:
```javascript
  UPDATE('значения из БД','таблица', [
                                          [ имя_колонки, новое_значение],
                                          [ имя_колонки, новое_значение],
                                            ...
                                        [,
                                        [
                                          [имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]],
                                          [имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]],
                                            ...
                                      [));_
```
Пример:
```javascript
function update_data(data)
{
	block = document.getElementById('update_example_block');

	set_column = block.getElementsByClassName('column')[0].value;
	set_value = block.getElementsByClassName('set_input')[0].value;

	where_column = 'ID';
	where_value = block.getElementsByClassName('where_input')[0].value;

	UPDATE(data, 'sandbox', [
					[set_column, set_value],
				],
				[
					[where_column, '=', where_value],
				]
	);
}
```
---
#### DELETE
Синтаксис:
```javascript
  DELETE('значения из БД', 'таблица', [
                                          [имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]],
                                          [имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]],
                                          ...
                                      ]);
```
Пример:
```javascript
function delete_data(data)
{
	block = document.getElementById('delete_example_block');

	column = block.getElementsByClassName('column')[0].value;
	value = block.getElementsByClassName('input_section')[0].value;

	DELETE( data, 'sandbox', [
					[column, 'LIKE', value]
				 ]);
}
```
---
### Примеры использования (для async/await-варианта)
Другой вариант использования - использование библиотеки с функционалом async/await.
Напомню особенность таких функций:
- await может использоваться только внутри  async-функций, это обязывает писать async перед всеми функциями, в которых намеривается использование библиотеки.

При работе с async/await использование очень напоминает стандартное поведение при программировании на серверных языках (к примеру, php). Мы так же получаем данные в переменную, потом их последовательно обрабатываем, а не как в варианте с callback получаем все и сразу, а потом уже разбираем полученные данные.

Почему тогда не использовать этот вариант, раз он так хорош?
Причины:
- Он рабаотет не так стабильно как вариант с callback, периодически выдавал ошибку ```CORS Missing Allow Origin```, возможно из-за очень частых запросов, так или иначе, варинат с callback не так часто ругался, но все же иногда бывает.
- Требует ставить ```async``` перед всеми функциями, которые будут обращатсья к БД (хотя это не такая весомая причина)     
- Не успевает. В следующем примере  идет SELECT, затем  INSERT и UPDATE, а затем опять SELECT. Стоит ожидать, что данные при 1м вызове SELECT и 2м будут отличаться, но это не совсем так... 
	- Причина 1. В логике отправки данных. Отправка UPDATE и DELETE состоит из 2х этапов:
		- 1й - Выбрать id строк через SELECT, которые удовлетворяют условию.
		- 2й - Отправить данные через iframe
Так вот, 1й этап хорошо отрабатывает, async/await срабатывают, но вот окончания 2го этапа функция await не дожидается, пока данные заносятся, мы уже снова можем вызвать SELECT и получить устаревшие данные.    
	- Причина 2. Google-таблице нужно немного времени, чтобы отобразить изменения, поэтому если мы в короткий промежуток времени (каким является время выполнения кода) вызовем несколько функций подряд, то таблица еще не отобразит изменения и мы получим старые данные. Поэтому между операциями считывания (SELECT) нужно делать паузы и, НАВЕРНОЕ, стоит использовать их больше одной за функцию.

В оправдание async:
- В callback варианте SELECT вообще не обращается к БД, а работает как фильтр над принятми данными, поэтому он тоже при вызове SELECT видит не новые данные скаолько бы мы INSERT и UPDATE не вызывали. 

Изменения синтаксиса по сравнению с callback-вариантом:
- Теперь мы не передаем в функции массив данных, теперь параметры функций еще больше схожи с реальным синтаксисом SQL. 

Синаксис :
```javascript
 SELECT('Имя_таблицы', 
		[имя_колонки_1, имя_колонки_2,..., имя_колонки_N], 
		[ 
			[имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]], 
			[имя_колонки, ВЫРАЖЕНИЕ, [значение_1, значение_2, ..., значение_N]],
			...
		]);
```
Пример функции:
```javascript
async function async_example()
{
	// Пример Извлечения данных и подсчета
	let data = await SELECT('sandbox', 
					['UserName', 'level'], 
					[
						['id', '!=', '10']
					]);
	let count= await COUNT_A('sandbox', [['id', '!=', '10']]);
	console.log(data, count); 
	
	// Вносим данные
	INSERT_A('sandbox', [
				['username', 'Аль-Ка-Пони'],
				['level', '35'],
				['say', 'Макфа']
			    ]);

	// Обновляем данные
	await UPDATE('sandbox', [
					['level', 'oVER 999']
				  ], 
				  [
					['Username', 'LIKE', 'Имба'],
				  ]);

	// Получим больше данных и выведем их в таблицу
	data = await SELECT('sandbox', 
					['ID' ,'UserName', 'level', 'say'], 
					[
						['id', '!=', '10']
					]);

	// Как видно, изменения не успели примениться
	// 1й вызов равен 2му, несмотря на то что между ними мы изменяли данные.
	console.log(data); 

	// Эта функция выводит данные в таблицу, ее нет в составе библиотеки
	print_result_as_array(
				['ID' ,'UserName', 'level', 'say'], 
				['ID', 'Имя', 'Уровень', 'Сказал'], 
				data
			      );
}
```

#### Преимущества async над callback:
+ Не надо вызывать специальную функцию ```queryGSQL()``` для вызова функции
+ Более удобный и интуитивный синтаксис, схожий с оригинальной работой с БД.

#### Недостатки async в сравнении с callback
-  Менее стабилен - главный минус.
- Требует перед всеми функциями, которые его используют, писать async